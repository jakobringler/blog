<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="The following notes only cover crowds with rigged agents, which are evaluated in real time during the simulation. Simple setups with instanced geometry caches are not covered here but may just as well be a viable solution."><title>Crowds</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://fxnotes.xyz//icon.png><link href=https://fxnotes.xyz/styles.76c8384632ed1e1f62917b5027e790d8.min.css rel=stylesheet><link href=https://fxnotes.xyz/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://fxnotes.xyz/js/darkmode.1feb6613eaffbf49acf3a460f176acbe.min.js></script>
<script src=https://fxnotes.xyz/js/util.39f53d45cb9520bdaf946bd063598b19.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script src=https://fxnotes.xyz/js/popover.37b1455b8f0603154072b9467132c659.min.js></script>
<script src=https://fxnotes.xyz/js/code-title.b35124ad8db0ba37162b886afb711cbc.min.js></script>
<script src=https://fxnotes.xyz/js/clipboard.c20857734e53a3fb733b7443879efa61.min.js></script>
<script src=https://fxnotes.xyz/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const BASE_URL="https://fxnotes.xyz/",fetchData=Promise.all([fetch("https://fxnotes.xyz/indices/linkIndex.2e7fca3b92e97f1c08a90cc4e6aba0f1.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://fxnotes.xyz/indices/contentIndex.ad5bc8f1794d8cf08870068c4b24be71.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const n=new URL(BASE_URL),s=n.pathname,o=window.location.pathname,i=s==o;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts();const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=i&&!0;drawGraph("https://fxnotes.xyz",t,[{"/moc":"#4388cc"}],t?{centerForce:1.3,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.3,linkDistance:1,opacityScale:3,repelForce:1,scale:1}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.4,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2}),initPopover("https://fxnotes.xyz",!0,!0)},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/fxnotes.xyz\/js\/router.9d4974281069e9ebb189f642ae1e3ca2.min.js"
    attachSPARouting(init, render)
  </script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-XYFD95KB4J"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XYFD95KB4J",{anonymize_ip:!1})}</script><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://fxnotes.xyz/js/full-text-search.24827f874defbbc6d529926cbfcfb493.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://fxnotes.xyz/>fx notes</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>Crowds</h1><p class=meta>Last updated
Nov 30, 2023
<a href=https://github.com/jakobringler/blog/tree/hugo/content/notes/Crowds.md rel=noopener>Edit Source</a></p><ul class=tags><li><a href=https://fxnotes.xyz/tags/houdini/>Houdini</a></li><li><a href=https://fxnotes.xyz/tags/cfx/>Cfx</a></li><li><a href=https://fxnotes.xyz/tags/fx/>Fx</a></li></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#agents>Agents</a><ol><li><a href=#agent-definition>Agent Definition</a></li><li><a href=#geometry-variations--agent-layers>Geometry Variations > Agent Layers</a></li><li><a href=#more-animations--agent-clips>More Animations > Agent Clips</a></li><li><a href=#debugging-your-agent>Debugging your Agent</a></li></ol></li><li><a href=#animation>Animation</a><ol><li><a href=#in-place-animation>In Place Animation</a></li><li><a href=#locomotion>Locomotion</a></li><li><a href=#foot-locking--agent-prep>Foot Locking > Agent Prep</a></li><li><a href=#clip-transitions>Clip Transitions</a></li><li><a href=#looping--blending--clip-properties>Looping & Blending > Clip Properties</a></li><li><a href=#blend-clips-together--transform-groups>Blend Clips Together > Transform Groups</a></li></ol></li><li><a href=#adjusting-clips-using-kinefx>Adjusting Clips using KineFX</a><ol><li><a href=#mirroring>Mirroring</a></li><li><a href=#on-the-fly-ik-chains>On the Fly IK Chains</a></li></ol></li><li><a href=#simulation>Simulation</a><ol><li><a href=#dop-setup>DOP Setup</a></li><li><a href=#triggers>Triggers</a></li><li><a href=#forces>Forces</a></li><li><a href=#ragdolls>Ragdolls</a></li><li><a href=#partial-ragdolls>Partial Ragdolls</a></li><li><a href=#vellum>Vellum</a></li></ol></li><li><a href=#post-sim-tweaks>Post Sim Tweaks</a><ol><li><a href=#agent-look-at>Agent Look At</a></li></ol></li><li><a href=#rendering>Rendering</a><ol><li><a href=#solaris-karma--hydra-delegates>Solaris, Karma & Hydra Delegates</a></li><li><a href=#mantra--third-party>Mantra & Third Party</a></li></ol></li></ol></nav></details></aside><p>The following notes only cover crowds with rigged agents, which are evaluated in real time during the simulation. Simple setups with instanced geometry caches are not covered here but may just as well be a viable solution.</p><a href=#agents><h2 id=agents><span class=hanchor arialabel=Anchor># </span>Agents</h2></a><p>Every crowd instance is an agent.</p><a href=#agent-definition><h3 id=agent-definition><span class=hanchor arialabel=Anchor># </span>Agent Definition</h3></a><p>An agent definition typically consists of a rig, one or more agent layers, which can hold different geometry variations or extra geometry and one or more agent clips, which store different animations for the rig.</p><p>To start creating an agent definition you need the <code>agent</code> SOP.</p><p>In the agent SOP you have multiple options to bring in your rig. The most straightforward way is to use a character rig and bring in a <code>Mocap Biped 3</code> character that ships with Houdini. This one is especially useful because it comes with many different animation clips which you can use.</p><p>I usually start by bringing in a t-posed character rig and name the clip &ldquo;rest&rdquo;.</p><a href=#geometry-variations--agent-layers><h3 id=geometry-variations--agent-layers><span class=hanchor arialabel=Anchor># </span>Geometry Variations > Agent Layers</h3></a><p>Agent layers are used to store different geometry variations in the same base agent. You can for example attach different faces, hairstyles, clothing or other accessories to the agent definition, which can be selected or randomized with attributes later on. To attach something to you agent you can use the <code>agent layer</code> SOP.</p><a href=#attaching-rigid-geometry-accessories-weapons-etc><h5 id=attaching-rigid-geometry-accessories-weapons-etc><span class=hanchor arialabel=Anchor># </span>Attaching Rigid Geometry (Accessories, Weapons etc.)</h5></a><p>I like the old <code>Agent Layer</code> HDA more then the new one when it comes to attaching rigid geometry, which is already placed correctly (hat, sword etc.), because it has the option <code>Keep Position When Attaching</code>.</p><p><img src=/notes/images/agentlayerbindings.png width=auto></p><p>Anything you want to attach, has to have a name attribute. You can pin it to the rig by choosing a bone which is used to transform the geometry correctly. See example below:</p><p><img src=/notes/images/agent_layer_assign.png width=auto></p><p>If you want to add something to your base geometry, make sure to activate <code>Source Layer</code> under <code>Use Existing Shapes</code> and set it to whatever you chose to name your default layer.</p><a href=#attaching-deforming-geometry-clothes-etc><h5 id=attaching-deforming-geometry-clothes-etc><span class=hanchor arialabel=Anchor># </span>Attaching Deforming Geometry (Clothes etc.)</h5></a><p>To attach clothes or other geometry that has to be deformed correctly you can leave the <code>Transform Name</code> empty and select a shape deformer.</p><p><img src=/notes/images/agentlayerbindingsshapedeform.png width=auto></p><p>For this to work the geometry has to be bound to the rig. When using the <code>Mocap Biped 3</code> I just crack the HDA open and bind the cloth geo to the rig using the shelf tools.</p><p><img src=/notes/images/agentlayercapture.png width=auto></p><p>Depending on your geo you may also get away with attribute transferring the <code>boneCapture</code> attribute from you t-posed character after <code>agent unpack</code>-ing them.</p><a href=#more-animations--agent-clips><h3 id=more-animations--agent-clips><span class=hanchor arialabel=Anchor># </span>More Animations > Agent Clips</h3></a><p>To give your agent more animations you can use the <code>Agent Clips</code> SOP.
You can provide the node with different datatypes:</p><ul><li>Character Rig</li><li>FBX</li><li>File</li><li>CHOP</li><li>USD</li><li>Motionclip</li></ul><p>When working with the default <code>Mocap Biped 3</code> I tend to create many different ones on OBJ level with different clips applied. Then I point the agent clips node to those OBJ objects.</p><p><img src=/notes/images/agentclips_mocapbiped3.png width=auto></p><p>Make sure to set the start / end frame correctly to avoid unnecessary handles. This also comes in handy later when setting up custom looping and blending.</p><p>To prepare you agents for locomotion in a simulation you should disable <code>Inplace Animation</code> on the mocap biped 3 and enable <code>Convert to In-Place Animation</code> on the agent clips SOP. More on locomotion further down.</p><a href=#debugging-your-agent><h3 id=debugging-your-agent><span class=hanchor arialabel=Anchor># </span>Debugging your Agent</h3></a><p>To visualize a specific agent (correct layers & clip) you can use the <code>agent edit</code> SOP.</p><p>To preview a crowd and randomize different aspects you can use the <code>crowd source</code> SOP in combination with <code>crowd assign layers</code>.</p><a href=#animation><h2 id=animation><span class=hanchor arialabel=Anchor># </span>Animation</h2></a><p>There are different ways to set up and use animation clips to create a crowd. Depending on your usecase you might get away with simple in-place animation or constant forward speed.</p><a href=#in-place-animation><h3 id=in-place-animation><span class=hanchor arialabel=Anchor># </span>In Place Animation</h3></a><p>WIP</p><a href=#locomotion><h3 id=locomotion><span class=hanchor arialabel=Anchor># </span>Locomotion</h3></a><p>WIP</p><a href=#foot-locking--agent-prep><h3 id=foot-locking--agent-prep><span class=hanchor arialabel=Anchor># </span>Foot Locking > Agent Prep</h3></a><p>WIP</p><a href=#clip-transitions><h3 id=clip-transitions><span class=hanchor arialabel=Anchor># </span>Clip Transitions</h3></a><p>The <code>Agent Clip Transition Graph</code> SOP lets you define, which and how these clips can blend between each other. There is a automatic function, which does a fairly good job a lot of the time. You can as well filter some of those automatic connections out by hand or create new ones that it didn&rsquo;t pick up by itself. I found the output of the automatic mode too confusing to work with when it comes to working with lots of clips: >15. I often end up just it up manually to be safe.</p><a href=#dealing-with-mirrored-clips-automatically><h5 id=dealing-with-mirrored-clips-automatically><span class=hanchor arialabel=Anchor># </span>Dealing with Mirrored Clips Automatically</h5></a><p>In this example I only set up 3 transitions by hand and the wrangle connects each mirrored version accordingly. It just assumes that all the timings and blend durations etc. are identical for the base and the mirrored clip.</p><p><img src=/notes/images/transitionmirror.png width=auto></p><p>// point wrangle &ldquo;clipname_to_name&rdquo;</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=n>s</span><span class=err>@</span><span class=n>name</span> <span class=o>=</span> <span class=n>s</span><span class=err>@</span><span class=n>clipname</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>// primitive wrangle &ldquo;create_mirror_connections&rdquo;</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=n>string</span> <span class=n>mirrorsuffix</span> <span class=o>=</span> <span class=s>&#34;_m&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>string</span> <span class=n>newclipname_a</span> <span class=o>=</span> <span class=n>s</span><span class=err>@</span><span class=n>clip_a</span> <span class=o>+</span> <span class=n>mirrorsuffix</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>string</span> <span class=n>newclipname_b</span> <span class=o>=</span> <span class=n>s</span><span class=err>@</span><span class=n>clip_b</span> <span class=o>+</span> <span class=n>mirrorsuffix</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>clip_a</span> <span class=o>=</span> <span class=n>nametopoint</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>s</span><span class=err>@</span><span class=n>clip_a</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>clip_a_m</span> <span class=o>=</span> <span class=n>nametopoint</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>newclipname_a</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>clip_b</span> <span class=o>=</span> <span class=n>nametopoint</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>s</span><span class=err>@</span><span class=n>clip_b</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>clip_b_m</span> <span class=o>=</span> <span class=n>nametopoint</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>newclipname_b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span><span class=p>(</span> <span class=n>clip_a_m</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span> <span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>prim</span> <span class=o>=</span> <span class=n>addprim</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=s>&#34;polyline&#34;</span><span class=p>,</span> <span class=n>clip_a_m</span><span class=p>,</span> <span class=n>clip_b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>pA_clip_a</span> <span class=o>=</span> <span class=n>setprimattrib</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=s>&#34;clip_a&#34;</span><span class=p>,</span> <span class=n>prim</span><span class=p>,</span> <span class=n>newclipname_a</span><span class=p>,</span> <span class=s>&#34;set&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>pA_clip_b</span> <span class=o>=</span> <span class=n>setprimattrib</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=s>&#34;clip_b&#34;</span><span class=p>,</span> <span class=n>prim</span><span class=p>,</span> <span class=n>s</span><span class=err>@</span><span class=n>clip_b</span><span class=p>,</span> <span class=s>&#34;set&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>pA_blend</span> <span class=o>=</span> <span class=n>setprimattrib</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=s>&#34;blend_durations&#34;</span><span class=p>,</span> <span class=n>prim</span><span class=p>,</span> <span class=n>f</span><span class=p>[]</span><span class=err>@</span><span class=n>blend_durations</span><span class=p>,</span> <span class=s>&#34;set&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>pA_sync</span> <span class=o>=</span> <span class=n>setprimattrib</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=s>&#34;sync_points&#34;</span><span class=p>,</span> <span class=n>prim</span><span class=p>,</span> <span class=n>f</span><span class=p>[]</span><span class=err>@</span><span class=n>sync_points</span><span class=p>,</span> <span class=s>&#34;set&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>pA_regions</span> <span class=o>=</span> <span class=n>setprimattrib</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=s>&#34;transition_regions&#34;</span><span class=p>,</span> <span class=n>prim</span><span class=p>,</span> <span class=n>f</span><span class=p>[]</span><span class=err>@</span><span class=n>transition_regions</span><span class=p>,</span> <span class=s>&#34;set&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span><span class=p>(</span> <span class=n>clip_b_m</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span> <span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>prim</span> <span class=o>=</span> <span class=n>addprim</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=s>&#34;polyline&#34;</span><span class=p>,</span> <span class=n>clip_a</span><span class=p>,</span> <span class=n>clip_b_m</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>pA_clip_a</span> <span class=o>=</span> <span class=n>setprimattrib</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=s>&#34;clip_a&#34;</span><span class=p>,</span> <span class=n>prim</span><span class=p>,</span> <span class=n>s</span><span class=err>@</span><span class=n>clip_a</span><span class=p>,</span> <span class=s>&#34;set&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>pA_clip_b</span> <span class=o>=</span> <span class=n>setprimattrib</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=s>&#34;clip_b&#34;</span><span class=p>,</span> <span class=n>prim</span><span class=p>,</span> <span class=n>newclipname_b</span><span class=p>,</span> <span class=s>&#34;set&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>pA_blend</span> <span class=o>=</span> <span class=n>setprimattrib</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=s>&#34;blend_durations&#34;</span><span class=p>,</span> <span class=n>prim</span><span class=p>,</span> <span class=n>f</span><span class=p>[]</span><span class=err>@</span><span class=n>blend_durations</span><span class=p>,</span> <span class=s>&#34;set&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>pA_sync</span> <span class=o>=</span> <span class=n>setprimattrib</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=s>&#34;sync_points&#34;</span><span class=p>,</span> <span class=n>prim</span><span class=p>,</span> <span class=n>f</span><span class=p>[]</span><span class=err>@</span><span class=n>sync_points</span><span class=p>,</span> <span class=s>&#34;set&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>pA_regions</span> <span class=o>=</span> <span class=n>setprimattrib</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=s>&#34;transition_regions&#34;</span><span class=p>,</span> <span class=n>prim</span><span class=p>,</span> <span class=n>f</span><span class=p>[]</span><span class=err>@</span><span class=n>transition_regions</span><span class=p>,</span> <span class=s>&#34;set&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span><span class=p>(</span> <span class=n>clip_a_m</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span> <span class=o>&amp;&amp;</span> <span class=n>clip_b_m</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span> <span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>prim</span> <span class=o>=</span> <span class=n>addprim</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=s>&#34;polyline&#34;</span><span class=p>,</span> <span class=n>clip_a_m</span><span class=p>,</span> <span class=n>clip_b_m</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>pA_clip_a</span> <span class=o>=</span> <span class=n>setprimattrib</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=s>&#34;clip_a&#34;</span><span class=p>,</span> <span class=n>prim</span><span class=p>,</span> <span class=n>newclipname_a</span><span class=p>,</span> <span class=s>&#34;set&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>pA_clip_b</span> <span class=o>=</span> <span class=n>setprimattrib</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=s>&#34;clip_b&#34;</span><span class=p>,</span> <span class=n>prim</span><span class=p>,</span> <span class=n>newclipname_b</span><span class=p>,</span> <span class=s>&#34;set&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>pA_blend</span> <span class=o>=</span> <span class=n>setprimattrib</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=s>&#34;blend_durations&#34;</span><span class=p>,</span> <span class=n>prim</span><span class=p>,</span> <span class=n>f</span><span class=p>[]</span><span class=err>@</span><span class=n>blend_durations</span><span class=p>,</span> <span class=s>&#34;set&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>pA_sync</span> <span class=o>=</span> <span class=n>setprimattrib</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=s>&#34;sync_points&#34;</span><span class=p>,</span> <span class=n>prim</span><span class=p>,</span> <span class=n>f</span><span class=p>[]</span><span class=err>@</span><span class=n>sync_points</span><span class=p>,</span> <span class=s>&#34;set&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>pA_regions</span> <span class=o>=</span> <span class=n>setprimattrib</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=s>&#34;transition_regions&#34;</span><span class=p>,</span> <span class=n>prim</span><span class=p>,</span> <span class=n>f</span><span class=p>[]</span><span class=err>@</span><span class=n>transition_regions</span><span class=p>,</span> <span class=s>&#34;set&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><a href=#looping--blending--clip-properties><h3 id=looping--blending--clip-properties><span class=hanchor arialabel=Anchor># </span>Looping & Blending > Clip Properties</h3></a><p>You can use the <code>Agent Clip Properties</code> SOP to specify which clip can loop and how long/where to blend to avoid jumps. This creates a point per clip, which gets fed into the DOP crowd object.</p><a href=#dealing-with-mirrored-clips-automatically-2><h5 id=dealing-with-mirrored-clips-automatically-2><span class=hanchor arialabel=Anchor># </span>Dealing with Mirrored Clips Automatically 2</h5></a><p>I use the following snippet combined with the one above to manage mirrores clips somewhat automatically.</p><p><img src="/notes/images/mirror properties.png" width=auto></p><p>It&rsquo;s important that it has access to the tranistion graph output via the second wrangle input.</p><p>As before we also need to create a <code>name</code> attribute based on the clipname.</p><p>// point wrangle &ldquo;create_mirror_properties&rdquo;</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=n>string</span> <span class=n>mirrorsuffix</span> <span class=o>=</span> <span class=s>&#34;_m&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>string</span> <span class=n>clipname</span> <span class=o>=</span> <span class=n>s</span><span class=err>@</span><span class=n>clipname</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>string</span> <span class=n>newclipname</span> <span class=o>=</span> <span class=n>clipname</span> <span class=o>+</span> <span class=n>mirrorsuffix</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>clip_m</span> <span class=o>=</span> <span class=n>nametopoint</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>newclipname</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>clip_exists</span> <span class=o>=</span> <span class=n>nametopoint</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>newclipname</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span><span class=p>(</span> <span class=n>clip_m</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span> <span class=o>&amp;&amp;</span> <span class=n>clip_exists</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>pt</span> <span class=o>=</span> <span class=n>addpoint</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>set</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=mi>0</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>pA_clipname</span> <span class=o>=</span> <span class=n>setpointattrib</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=s>&#34;clipname&#34;</span><span class=p>,</span> <span class=n>pt</span><span class=p>,</span> <span class=n>newclipname</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>pA_agent</span> <span class=o>=</span> <span class=n>setpointattrib</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=s>&#34;agentname&#34;</span><span class=p>,</span> <span class=n>pt</span><span class=p>,</span> <span class=n>s</span><span class=err>@</span><span class=n>agentname</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>pA_clipnamesrc</span> <span class=o>=</span> <span class=n>setpointattrib</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=s>&#34;clipname_source&#34;</span><span class=p>,</span> <span class=n>pt</span><span class=p>,</span> <span class=n>newclipname</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>pA_blend_a</span> <span class=o>=</span> <span class=n>setpointattrib</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=s>&#34;blend_duration_after&#34;</span><span class=p>,</span> <span class=n>pt</span><span class=p>,</span> <span class=err>@</span><span class=n>blend_duration_after</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>pA_blend_b</span> <span class=o>=</span> <span class=n>setpointattrib</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=s>&#34;blend_duration_before&#34;</span><span class=p>,</span> <span class=n>pt</span><span class=p>,</span> <span class=err>@</span><span class=n>blend_duration_before</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>pA_loop</span> <span class=o>=</span> <span class=n>setpointattrib</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=s>&#34;enable_looping&#34;</span><span class=p>,</span> <span class=n>pt</span><span class=p>,</span> <span class=err>@</span><span class=n>enable_looping</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>pA_gait</span> <span class=o>=</span> <span class=n>setpointattrib</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=s>&#34;gait_speed&#34;</span><span class=p>,</span> <span class=n>pt</span><span class=p>,</span> <span class=err>@</span><span class=n>gait_speed</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>pA_loopr</span> <span class=o>=</span> <span class=n>setpointattrib</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=s>&#34;loop_range&#34;</span><span class=p>,</span> <span class=n>pt</span><span class=p>,</span> <span class=n>u</span><span class=err>@</span><span class=n>loop_range</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>pA_sampler</span> <span class=o>=</span> <span class=n>setpointattrib</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=s>&#34;sample_rate&#34;</span><span class=p>,</span> <span class=n>pt</span><span class=p>,</span> <span class=err>@</span><span class=n>sample_rate</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>pA_start_time</span> <span class=o>=</span> <span class=n>setpointattrib</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=s>&#34;start_time&#34;</span><span class=p>,</span> <span class=n>pt</span><span class=p>,</span> <span class=err>@</span><span class=n>start_time</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><a href=#blend-clips-together--transform-groups><h3 id=blend-clips-together--transform-groups><span class=hanchor arialabel=Anchor># </span>Blend Clips Together > Transform Groups</h3></a><p>WIP</p><a href=#adjusting-clips-using-kinefx><h2 id=adjusting-clips-using-kinefx><span class=hanchor arialabel=Anchor># </span>Adjusting Clips using KineFX</h2></a><a href=#mirroring><h3 id=mirroring><span class=hanchor arialabel=Anchor># </span>Mirroring</h3></a><p>The <code>Rig Mirror Pose</code> SOP allows you to flip your clips and essentially double the amount of animations you have practically for free.</p><p>It doesn&rsquo;t work all the time because you need to provide it some kind of rest post / somewhat symmetrical centered frame of your clip.</p><p><img src=/notes/images/rigmirrorpose_crowd.png width=auto></p><p>You can feed the updated <code>Motion Clip</code> back in an <code>Agent Clip</code> SOP.</p><a href=#on-the-fly-ik-chains><h3 id=on-the-fly-ik-chains><span class=hanchor arialabel=Anchor># </span>On the Fly IK Chains</h3></a><p>This allows you to easily manipulate and extend your animation library!</p><ul><li>Drop down a <code>Agent Animation Unpack</code> SOP</li><li>time freeze and blast out any bones you want to add an animation to</li><li>animate with a <code>Rig Pose</code> SOP</li><li>Use the <code>IK Chains</code> SOP to blend in the animation<ul><li>make sure to enable <code>Match By Name</code></li></ul></li><li>Drop down a <code>Motion Clip</code> and feed it back to an <code>Agent Clip</code> node to create a new clip</li></ul><p><img src=/notes/images/kinefx_ikchains_oncrowd.gif width=auto></p><a href=#simulation><h2 id=simulation><span class=hanchor arialabel=Anchor># </span>Simulation</h2></a><p>WIP</p><a href=#dop-setup><h3 id=dop-setup><span class=hanchor arialabel=Anchor># </span>DOP Setup</h3></a><p>WIP</p><a href=#triggers><h3 id=triggers><span class=hanchor arialabel=Anchor># </span>Triggers</h3></a><p>WIP</p><a href=#forces><h3 id=forces><span class=hanchor arialabel=Anchor># </span>Forces</h3></a><p>WIP</p><a href=#ragdolls><h3 id=ragdolls><span class=hanchor arialabel=Anchor># </span>Ragdolls</h3></a><p>WIP</p><a href=#partial-ragdolls><h3 id=partial-ragdolls><span class=hanchor arialabel=Anchor># </span>Partial Ragdolls</h3></a><p>WIP</p><a href=#vellum><h3 id=vellum><span class=hanchor arialabel=Anchor># </span>Vellum</h3></a><p>WIP</p><a href=#post-sim-tweaks><h2 id=post-sim-tweaks><span class=hanchor arialabel=Anchor># </span>Post Sim Tweaks</h2></a><a href=#agent-look-at><h3 id=agent-look-at><span class=hanchor arialabel=Anchor># </span>Agent Look At</h3></a><p>You can make agents look at stuff after having already simulated everything! That is amazing and very simple to set up. You just need a <code>Agent Look At</code> SOP. Pipe in your crowd cache and you are good to go. You can use it in Simulation or in Live mode. If you don&rsquo;t simulate any turns you just directly modify the skeletons rotation to make each agent look at a target. Might have some snappy unexpected behavior but is usually good enough.</p><a href=#rendering><h2 id=rendering><span class=hanchor arialabel=Anchor># </span>Rendering</h2></a><a href=#solaris-karma--hydra-delegates><h3 id=solaris-karma--hydra-delegates><span class=hanchor arialabel=Anchor># </span>Solaris, Karma & Hydra Delegates</h3></a><a href=#texture-variations-in-solaris><h5 id=texture-variations-in-solaris><span class=hanchor arialabel=Anchor># </span>Texture Variations in Solaris</h5></a><ol><li><strong>Karma CPU (VEX Shaders)</strong></li></ol><p>For VEX Shaders you can modify many shader graph parameters using the <code>Material Variation</code> LOP. This way you can randomize or write custom logic in a vex snippet to define e.g. which path your diffuse texture is supposed to come from.</p><p><img src=/notes/images/assign_different_textures_crowd_karmavex.png width=auto></p><ul><li>the <strong>index</strong> variable is a unique id per element</li><li>the <strong>value</strong> variable is used to write back to the parameter specified under &ldquo;Name&rdquo;</li></ul><ol start=2><li><strong>Karma XPU (MTLX Shaders)</strong></li></ol><p>As of now (Houdini 19.5) it&rsquo;s not possible to get access to the filepath parameters in the <code>MTLX Image</code> node. The only node that can be accessed is the <code>MTLX Geometry Property Value</code>. Unfortunately you can&rsquo;t feed the <code>MTLX Image</code> node any string inputs. That&rsquo;s why you have to load in all your textures in separate nodes and vary the assignment with some switch logic based on your geompropvalue input.</p><p>I usually assign different point attributes to the packed agent crowd in SOPs and read them in the shader and don&rsquo;t even bother using the <code>Material Variation</code> node.</p><p><img src=/notes/images/geompropvalue_shadersetup_crowd_matvariation.png width=auto></p><a href=#targetting-sub-geometry-in-solaris><h5 id=targetting-sub-geometry-in-solaris><span class=hanchor arialabel=Anchor># </span>Targetting Sub-Geometry in Solaris</h5></a><p>Let&rsquo;s say you have different agents with different layers. Some of those layers include extra geometry like a hat that requires a different shader than the main agent body. In OBJ / Mantra world you would have assigned the correct shader using material style sheets.</p><p>In USD you can&rsquo;t easily access sub-geometry when you are using <code>Instanced SkelRoots</code> (which is the default and recommended setting when working with crowds / SOP Crowd Import). If you wanted to assign specific shaders to different parts of your agent you would have to import the crowd as <code>SkelRoots</code> (not instanced) which you should probably only ever do for certain hero agents to not run out of RAM.</p><p>What now?</p><p>You can do this via collections! (a USD thing) The setup isn&rsquo;t very straight forward though and I wouldn&rsquo;t have been able to get it to work without
<a href="https://www.sidefx.com/forum/topic/81706/?page=1#post-362705" rel=noopener>this</a> forum post explaining how to do it.</p><p>The setup:</p><p>I want to assign the &ldquo;hat&rdquo; geometry a different shader then the rest of the agents. As explained above normal assignment using e.g. wildcards doesn&rsquo;t work:</p><p><img src="/notes/images/Pasted image 20231106143329.png" width=auto></p><ol><li>Drop down a <code>SOP Crowd Import</code> LOP and point it to your crowd</li><li>Create a <code>Collection</code> LOP<ol><li>give it a name</li><li>check the <code>Allow Instance Proxies in Collection</code> toggle under options</li><li>use the <code>%reference</code> expression to point to your geometry</li></ol></li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=o>%</span><span class=nl>reference</span><span class=p>:</span><span class=o>/</span><span class=n>crowd</span><span class=o>/</span><span class=n>agentdefinitions</span><span class=o>/</span><span class=n>agent</span><span class=o>/</span><span class=n>shapelibrary</span><span class=o>/</span><span class=n>hat</span>
</span></span></code></pre></td></tr></table></div></div><p><img src="/notes/images/Pasted image 20231106142401.png" width=auto></p><ol start=3><li>Create a material library node and build some shaders</li><li>Use the <code>Assign Material</code> LOP to assign the material based on the collection name<ol><li>make sure to use <code>%yourCollectionName</code></li><li>set the Method to <code>Collection Based</code></li><li>point the <code>Path</code> to your crowd object</li></ol></li></ol><p><img src="/notes/images/Pasted image 20231106142535.png" width=auto></p><p>This should work in all hydra delegates (tested in Karma & Redshift).</p><p><img src="/notes/images/Pasted image 20231106143438.png" width=auto></p><a href=#mantra--third-party><h3 id=mantra--third-party><span class=hanchor arialabel=Anchor># </span>Mantra & Third Party</h3></a><a href=#material-style-sheets><h5 id=material-style-sheets><span class=hanchor arialabel=Anchor># </span>Material Style Sheets</h5></a><p>I didn&rsquo;t bother writing anything down because Mantra and Style Sheets are pretty much gone with USD and Solaris being more and more adopted. The
<a href=https://www.sidefx.com/tutorials/zombies-for-everyone-quick-intro-to-crowds/ rel=noopener>Zombies for Everyone</a> course chapters 20 - 22 give you a good idea of the basics.</p><hr><p>sources / further reading:</p><ul><li><a href=https://www.sidefx.com/tutorials/zombies-for-everyone-quick-intro-to-crowds/ rel=noopener>Zombies for Everyone | Quick Intro to Crowds - SideFX</a></li><li><a href=https://www.sidefx.com/tutorials/intro-to-crowds/ rel=noopener>Intro to Crowds - SideFX</a></li><li><a href="https://www.youtube.com/playlist?list=PLyzn6-dYuCbFby6Ynlk5ziOM-YsTRw68K" rel=noopener>🚶🏻‍♂️ Crowds in Houdini Tutorials - Juanjo Martínez</a></li><li><a href=https://www.tokeru.com/cgwiki/HoudiniCrowd.html rel=noopener>Crowds - cgwiki</a></li><li><a href="https://www.sidefx.com/forum/topic/81706/?page=1#post-362705" rel=noopener>Targetting sub-geometry in Solaris in a crowd sim - SideFX Forum</a></li><li><a href="https://www.youtube.com/watch?v=1cLPYWj4Lqk" rel=noopener>Be in Control - Crowds and KineFX | Mikael Pettersen | Houdini 18.5 HIVE - SideFX</a></li></ul></article><hr><div class=page-end><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li><a href=/notes/Houdini/ data-ctx=Crowds data-src=/notes/Houdini class=internal-link>Houdini</a></li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://fxnotes.xyz/js/graph.8cefef8d9a78cb623e39ee66e5a4af0e.js></script></div></div><div id=contact_buttons><footer><p>Made by <a href=https://www.jakobringler.com>Jakob Ringler</a> using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2024</p><ul><li><a href=https://fxnotes.xyz/>Home</a></li><li><a href=https://twitter.com/jakobrin>Twitter</a></li><li><a href=https://github.com/jakobringler>Github</a></li><li><a href=https://fxnotes.xyz/notes/Legal/>Legal / Impressum</a></li></ul></footer></div></div></body></html>