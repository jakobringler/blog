<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="Most of the following are my personal notes on Jeff Wagners awesome masterclass on Collisions. It&rsquo;s a bit on the longer side of presentations (6ish hours in 3 parts), but I highly recommend watching it!"><title>Collisions</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://fxnotes.xyz//icon.png><link href=https://fxnotes.xyz/styles.76c8384632ed1e1f62917b5027e790d8.min.css rel=stylesheet><link href=https://fxnotes.xyz/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://fxnotes.xyz/js/darkmode.1feb6613eaffbf49acf3a460f176acbe.min.js></script>
<script src=https://fxnotes.xyz/js/util.39f53d45cb9520bdaf946bd063598b19.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script src=https://fxnotes.xyz/js/popover.37b1455b8f0603154072b9467132c659.min.js></script>
<script src=https://fxnotes.xyz/js/code-title.b35124ad8db0ba37162b886afb711cbc.min.js></script>
<script src=https://fxnotes.xyz/js/clipboard.c20857734e53a3fb733b7443879efa61.min.js></script>
<script src=https://fxnotes.xyz/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const BASE_URL="https://fxnotes.xyz/",fetchData=Promise.all([fetch("https://fxnotes.xyz/indices/linkIndex.1eacc423bdd0dd74ff03e22882245fda.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://fxnotes.xyz/indices/contentIndex.d5f29ddd07f30b4fdf65f1fe68a7234c.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const n=new URL(BASE_URL),s=n.pathname,o=window.location.pathname,i=s==o;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts();const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=i&&!0;drawGraph("https://fxnotes.xyz",t,[{"/moc":"#4388cc"}],t?{centerForce:1.3,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.3,linkDistance:1,opacityScale:3,repelForce:1,scale:1}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.4,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2}),initPopover("https://fxnotes.xyz",!0,!0)},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/fxnotes.xyz\/js\/router.9d4974281069e9ebb189f642ae1e3ca2.min.js"
    attachSPARouting(init, render)
  </script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-XYFD95KB4J"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XYFD95KB4J",{anonymize_ip:!1})}</script><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://fxnotes.xyz/js/full-text-search.24827f874defbbc6d529926cbfcfb493.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://fxnotes.xyz/>fx notes</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>Collisions</h1><p class=meta>Last updated
Oct 24, 2023
<a href=https://github.com/jakobringler/blog/tree/hugo/content/notes/Collisions.md rel=noopener>Edit Source</a></p><ul class=tags><li><a href=https://fxnotes.xyz/tags/houdini/>Houdini</a></li><li><a href=https://fxnotes.xyz/tags/fx/>Fx</a></li></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#how-colliders-are-built-in-dops>How Colliders are built in DOPs</a><ol><li><a href=#ground-plane>Ground Plane</a></li><li><a href=#static-object>Static Object</a></li><li><a href=#deforming-object>Deforming Object</a></li></ol></li><li><a href=#different-solvers-expect-different-colliders>Different Solvers Expect Different Colliders</a><ol><li><a href=#pop-solver>POP Solver</a></li><li><a href=#grain-and-wire-solver>Grain and Wire Solver</a></li><li><a href=#flip-solver>FLIP Solver</a></li><li><a href=#pyro-solver>PYRO Solver</a></li><li><a href=#vellum-solver>VELLUM Solver</a></li><li><a href=#cloth-solver>CLOTH Solver</a></li><li><a href=#solid-fem-solver>SOLID (FEM) Solver</a></li><li><a href=#rigid-body-bullet-solver>Rigid Body (BULLET) Solver</a></li><li><a href=#bullet-collision-objects-and-other-solvers>BULLET Collision Objects and other Solvers</a></li></ol></li><li><a href=#colliders-and-substeps>Colliders and Substeps</a><ol><li><a href=#substepping>Substepping</a></li><li><a href=#global-vs-solver-substeps>Global vs Solver Substeps</a></li><li><a href=#viewport-debugging-playback-rate>Viewport Debugging (Playback Rate)</a></li><li><a href=#collider-substep-interpolation>Collider Substep Interpolation</a></li><li><a href=#smoothing-out-fast-moving-colliders>Smoothing Out Fast Moving Colliders</a></li></ol></li><li><a href=#deforming-colliders>Deforming Colliders</a></li><li><a href=#general-collider-workflows>General Collider Workflows</a><ol><li><a href=#collision-vdbs-from-bad-topology>Collision VDBs from Bad Topology</a></li><li><a href=#performance>Performance</a></li></ol></li></ol></nav></details></aside><p>Most of the following are my personal notes on Jeff Wagners awesome masterclass on
<a href=https://www.sidefx.com/community/collision-geometry-in-dop-simulations/ rel=noopener>Collisions</a>. It&rsquo;s a bit on the longer side of presentations (6ish hours in 3 parts), but I highly recommend watching it! It also comes with demo files and a PDF which I will quote multiple times below.</p><a href=#how-colliders-are-built-in-dops><h2 id=how-colliders-are-built-in-dops><span class=hanchor arialabel=Anchor># </span>How Colliders are built in DOPs</h2></a><p>DOPs is set up in a way that most HDAs are built from an empty object. Then there is data added to it. &ldquo;Data&rdquo; can mean loads of things:</p><ul><li>geometry</li><li>physical simulation parameters</li><li>display geometry</li><li>render parameters to define what is visualized in the viewport</li></ul><a href=#ground-plane><h3 id=ground-plane><span class=hanchor arialabel=Anchor># </span>Ground Plane</h3></a><p><img src=/notes/images/groundplane_deconstruct.png width=auto></p><ol><li>(yellow) creates volume collision data and sets render parms to make it invisible in the viewport</li><li>(red) applies motion/position data (also from OBJ level)</li><li>(green) applies physical parameters such as <code>bounce</code> and <code>friciton</code></li><li>(blue) can be used to turn object active</li><li>(purple) fetches display geometry and sets render parms</li><li>(pink) labels collider</li><li>(peach) stores info where the DOP object comes from</li><li>(orange) bullet collision setup</li><li>(dark green) display geometry SOP network</li><li>(grey blue) collision geometry SOP network</li></ol><p>This is just a sparse overview to go back to. To really understand it watch part 1 of Jeff Wagner&rsquo;s presentation (00:12:00 - 00:25:00).</p><a href=#static-object><h3 id=static-object><span class=hanchor arialabel=Anchor># </span>Static Object</h3></a><p>The <code>static object</code> DOP is a little bit more involved then the ground plane, but it&rsquo;s based on the same concepts .. just with more boilerplate nodes and switch logic around it.</p><p><img src=/notes/images/staticobject_deconstruct.png width=auto></p><p>I matched the node colors to show the similarities.</p><a href=#deforming-object><h3 id=deforming-object><span class=hanchor arialabel=Anchor># </span>Deforming Object</h3></a><p>This just exists as a shelf tool which sets up the <code>static object</code> DOP correctly to account for transformations and deformations.</p><a href=#different-solvers-expect-different-colliders><h2 id=different-solvers-expect-different-colliders><span class=hanchor arialabel=Anchor># </span>Different Solvers Expect Different Colliders</h2></a><a href=#pop-solver><h3 id=pop-solver><span class=hanchor arialabel=Anchor># </span>POP Solver</h3></a><p>Supported Collision data:</p><ol><li>SDF Volume geometry (default)<ul><li>very fast, real 3D</li></ul></li><li>Height Fields (same as SDF Volume data)<ul><li>very fast but no holes</li><li>only <code>unchanged</code>, <code>stop</code>, <code>die</code> response / hit behaviour work</li></ul></li><li>Polygonal geometry<ul><li>slow ( has to calculate primitive, primuvs for each particle )</li><li>can be used for complex systems that depend on per hit data like <code>hitnormal</code> etc.</li><li><code>slide</code>, <code>stick</code> response / hit behaviour only works with polygons</li></ul></li></ol><p>Particle simulations tend to be either of the following two types:</p><ol><li>A LOT of dumb particles</li><li>A FEW smart particles</li></ol><blockquote><p>// from the SideFX pdf:</p><p>Dumb particles have no real rules other than forces motivating them through space. Using the default SDF Volume type colliders is the preferred method. The test to see if a particle is in or out of an SDF is a continuous linear lookup. The solver can predict when a particle is about to go from +ve outside space to =ve inside space of the SDF Volume. Remember the SDF is built from surface geometry. It encodes the surface upon SDF creation so all the hard work has been done.
Am I in or out? SDF look up is almost instantaneous.</p><p>If you have smart particles with lots of rules especially around collisions, you can choose to use polygons. When you collide against polygons, you can inherit the bi-linearly interpolated attribute values from the polygon faces. This means that you need to record the polygon face number and the actual local u and v hit co-ordinates on that polygon face.</p></blockquote><p>To make particles collide with polygons you can use the <code>POP Collision Detect DOP</code> in the pop source stream of the simulation. Just give it a SOP path and it should work.</p><p><img src="/notes/images/Pasted image 20231018130122.png" width=auto></p><a href=#particle-orientations-and-collisions><h5 id=particle-orientations-and-collisions><span class=hanchor arialabel=Anchor># </span>Particle Orientations and Collisions</h5></a><blockquote><p>// from the SideFX pdf:</p><p>When particles collide against a surface, the velocity vector of the particle is mirrored along the hit normal or the tangent of the face. This works for both SDF Volume colliders and polygonal surface colliders.</p><p>By default, any instanced or copied geometry to these points will use the <code>v</code> velocity attribute to orient the geometry, if there is no <code>vector4 orient</code> quaternion attribute on the geometry</p></blockquote><a href=#grain-and-wire-solver><h3 id=grain-and-wire-solver><span class=hanchor arialabel=Anchor># </span>Grain and Wire Solver</h3></a><p>Grains uses the pop solver and the wire solver behaves like POPs so the same rules apply to both.</p><p>Supported Collision data:</p><ol><li>SDF Volume geometry (default)</li><li>Height Fields (same as SDF Volume data)</li><li>Polygonal geometry</li></ol><a href=#flip-solver><h3 id=flip-solver><span class=hanchor arialabel=Anchor># </span>FLIP Solver</h3></a><p>Unlike the POP Solver which can take different but separate collider types the <a href=/notes/FLIP rel=noopener class=internal-link data-src=/notes/FLIP>FLIP</a> solver needs polygonal geometry <strong>AND</strong> a surface vdb!</p><p>Supported Collision data:</p><ol><li>SDF Volume data for surface collisions</li><li>Height Fields (same as SDF Volume data)</li><li>Volume Velocity Fields</li><li>(Polygon surfaces through POP Collision Detect but at your own peril)</li></ol><p>On the FLIP solver under <code>Volume Motion</code> > <code>Collision</code> you can specify where to read the collision velocities from (Point or Volume).</p><blockquote><p>// from the SideFX pdf:</p><p>The main issue is resolution. For test FLIP sims and detailed colliders, you will not have enough collision detail. You have to enable.</p><p>Thin colliders like cups and vessels containing fluid can benefit from: • Thick boundary walls.
• if moving fast, lots of substeps and blending between frames. (Default shelf setup).
• Extra velocity on the collider adding in some surface normals to the velocity.</p></blockquote><p>To avoid precision errors make sure to simulate in a moderate scene scale ( not too small or too big ). I wrote a little more about it <a href=/notes/General-Workflow-Tips#simulation-scale rel=noopener class=internal-link data-src=/notes/General-Workflow-Tips>here</a>.</p><a href=#pyro-solver><h3 id=pyro-solver><span class=hanchor arialabel=Anchor># </span>PYRO Solver</h3></a><p>Supported Collision data:</p><ol><li>SDF Volume data for surface collisions</li><li>Height Fields (same as SDF Volume data)</li><li>Volume Velocity Fields</li></ol><blockquote><p>// from the SideFX pdf:</p><p>You can use particles as collider sources using the <code>Gas Particle To Field</code> DOP to take your points and convert them in to SDF collision fields for use by the Pyro Solver.</p><p>You need to name the field “collision”.</p><p>If you go this route, you also have to use a second <code>Gas Particle To Field</code> DOP to construct a companion “collisionvel” vector field to hold the velocity of your collider. [&mldr;]</p><p>Same goes for FLIP colliders. How these merge in to other existing collision and collisionvel fields is determined by how you mix these in with the <code>Gas Linear Combination</code> DOP</p></blockquote><a href=#vellum-solver><h3 id=vellum-solver><span class=hanchor arialabel=Anchor># </span>VELLUM Solver</h3></a><p><a href=/notes/VELLUM rel=noopener class=internal-link data-src=/notes/VELLUM>VELLUM</a> is an XPBD (Extended <strong>Position-Based Dynamics</strong>) solver.</p><p>Supported Collision data:</p><ul><li>Polygonal geometry</li></ul><p>as the name &ldquo;position based&rdquo; suggests there is no way to use sdf volumes as colliders, because they are only represented as a single point in Houdini.</p><p>There isn&rsquo;t much to take care of except making sure that you have a consistent point count on the collider geometry.</p><p>You can use the <code>POP Collision Ignore</code> node in DOPs to specify which vellum geometry is affected by which collider. Read more
<a href=https://www.sidefx.com/docs/houdini/vellum/collisions.html rel=noopener>here</a>.</p><a href=#cloth-solver><h3 id=cloth-solver><span class=hanchor arialabel=Anchor># </span>CLOTH Solver</h3></a><p>Cloth supported Collision data:</p><ol><li>Cloth colliders from the Cloth shelf</li><li>Polygonal geometry (supports swept collisions for sub-frame interpolation)</li><li>SDF Volume data for surface collisions</li><li>Height Fields (same as SDF Volume data)</li><li>Volume Velocity Fields</li></ol><p>Cloth solver (subset of the Solid FEM solver) is a special solver that prefers to collide against other cloth objects.</p><a href=#solid-fem-solver><h3 id=solid-fem-solver><span class=hanchor arialabel=Anchor># </span>SOLID (FEM) Solver</h3></a><p>Solid supported Collision data:</p><ol><li>Solid colliders from the Solid shelf</li><li>Polygonal geometry (supports swept collisions for sub-frame interpolation)</li><li>SDF Volume data for surface collisions</li><li>Height Fields (same as SDF Volume data)</li><li>Volume Velocity Fields</li></ol><blockquote><p>// from the SideFX pdf:</p><p>The Solid solver uses FEM or Finite Element Methods to stimulate different materials from soft fleshy objects to concrete and everything in between.</p><p>Collisions with like tet objects that are very rigid is a robust way of managing collisions. But many times we wish to integrate the Solid solver with other collision data such as polygon data. You have two choices: Use the Collision Shelf Static or Deforming tools to introduce polygon colliders, or use the Solid shelf and create a static solid collider comprised of tets.</p></blockquote><a href=#rigid-body-bullet-solver><h3 id=rigid-body-bullet-solver><span class=hanchor arialabel=Anchor># </span>Rigid Body (BULLET) Solver</h3></a><p>Supported Collision data:</p><ul><li>Bullet Collision data (solver specific)</li><li>Height Fields</li></ul><p>Different Collider Types:</p><ol><li>Geometry Based<ul><li>Convex Hull</li><li>Concave (not recommended)</li></ul></li><li>Primitive Types<ul><li>Box</li><li>Capsule</li><li>Cylinder</li><li>Compound (important!)</li><li>Sphere</li><li>Plane</li></ul></li><li>SDF Based<ul><li>Height Field</li></ul></li></ol><a href=#solver-substeps><h5 id=solver-substeps><span class=hanchor arialabel=Anchor># </span>Solver Substeps:</h5></a><p>Global Substeps x Bullet Substeps = Total Substeps</p><p>Important to resolve collisions / interpenetration / tunneling => especially when lots of different objects are close to each other.</p><p>Bullet substeps work like this:</p><p>N = number of bullet substeps</p><ol><li>Take 1 global substep and divide it in N bullet substeps</li><li>Take the velocity and divide it through N as well</li><li>Move geometry forward N times by velocity/N and resolve collisions after each step</li></ol><p>recommended minimum: 10</p><a href=#height-fields-as-bullet-colliders><h5 id=height-fields-as-bullet-colliders><span class=hanchor arialabel=Anchor># </span>Height Fields as Bullet Colliders:</h5></a><blockquote><p>// from the SideFX pdf:</p><p>Height fields make excellent bullet colliders. You can represent complex surfaces with height fields for efficient bullet simulations.</p><p>Your only limitation is with height fields themselves. They do not support overhangs. The height fields by their nature are both concave and convex. It is good to know that there is a very fast solution to describing terrain collisions in Bullet without resorting to creating manifold terrain colliders.</p><p>As with infinite plane colliders, you can use several height fields to define collision planes in your Bullet simulations.</p><p>Just like infinite planes, these height field colliders have an inside and an outside. You can think of these as SDF colliders defined by a single voxel high volume.</p><p>Unlike infinite planes, height fields are not infinite. The size of the height field is what the bullet solver uses. Any collisions beyond the height field will will not be by that height field.</p></blockquote><p>You can use the <code>Terrain Object</code> shelf tool under the <code>Collisions</code> to set this up correctly.</p><a href=#concave-colliders-with-convex-hulls><h5 id=concave-colliders-with-convex-hulls><span class=hanchor arialabel=Anchor># </span>Concave Colliders with Convex Hulls</h5></a><p>Default bullet colliders are convex:</p><p><img src="/notes/images/Pasted image 20231018110552.png" width=auto></p><p>To work around this without sacrificing performance too much there are two similar ways. Both split up the geometry into smaller pieces which will be &ldquo;convex hulled&rdquo; separately. Make sure to enable <code>Create Convex Hull per Set of Connected Primitives</code>!</p><ol><li><strong>Voronoi Fracture</strong></li></ol><p><img src="/notes/images/Pasted image 20231018110815.png" width=auto></p><ol start=2><li><strong>Convex Decomposition</strong></li></ol><p><img src="/notes/images/Pasted image 20231018111022.png" width=auto></p><p>You can also use boolean operations or develop your own algorithm that splits up the geometry into mostly convex pieces.</p><a href=#concave-colliders-with-spheres><h5 id=concave-colliders-with-spheres><span class=hanchor arialabel=Anchor># </span>Concave Colliders with Spheres</h5></a><p>If you need fast but pretty accurate collisions in RBD sims you can generate loads of little spheres inside the geometry and use those as a compound to calculate collisions. In fact this is the fastest way to calculate collisions, because you only need to know 1 point and the radius to calculate where collisions would occur.</p><p><img src=/notes/images/sphere_bullet_collider.png width=auto></p><p>Make sure to use <code>bake ODE</code> and set the <code>Geometry Representation</code> on the RBD Object to <code>Compound</code>.</p><p>You can then apply the transformation back to the original geometry by using <code>extract transform</code> for example.</p><a href=#bullet-collision-objects-and-other-solvers><h3 id=bullet-collision-objects-and-other-solvers><span class=hanchor arialabel=Anchor># </span>BULLET Collision Objects and other Solvers</h3></a><p>List of possible combinations with bullet colliders:</p><ul><li>bullet and particles</li><li>bullet and grains</li><li>bullet and wires</li><li>bullet and flip fluids</li><li>bullet and pyro</li><li>bullet and cloth</li><li>bullet and solids (FEM)</li></ul><a href=#bullet-and-particles-or-grains><h5 id=bullet-and-particles-or-grains><span class=hanchor arialabel=Anchor># </span>BULLET and Particles or Grains</h5></a><p>Particles collide quite well against bullet simulation objects.</p><a href=#bullet-and-wires><h5 id=bullet-and-wires><span class=hanchor arialabel=Anchor># </span>BULLET and Wires</h5></a><p>Wires collide against bullet objects, but there won&rsquo;t be any mutual affection. It&rsquo;s hard to get this working without extensive sop solver trickery and extremely light bullet pieces. Use <a href=/notes/VELLUM rel=noopener class=internal-link data-src=/notes/VELLUM>VELLUM</a> instead!</p><a href=#bullet-and-flip><h5 id=bullet-and-flip><span class=hanchor arialabel=Anchor># </span>BULLET and FLIP</h5></a><p>FLIP uses the Bullet collision geometry to build it&rsquo;s colliders. When using packed RBD objects the geometry you see in the viewport only exists on the GPU, which is why FLIP can&rsquo;t access it. Same thing applies to pyro.</p><a href=#bullet-and-pyro><h5 id=bullet-and-pyro><span class=hanchor arialabel=Anchor># </span>BULLET and Pyro</h5></a><p>BULLET objects collide the same way as in FLIP. No access to packed geometry.</p><a href=#bullet-and-solids-fem-and-cloth><h5 id=bullet-and-solids-fem-and-cloth><span class=hanchor arialabel=Anchor># </span>BULLET and Solids (FEM) and Cloth</h5></a><p>Possible. Needs higher number of substeps on DOP network to get stable results.
Subdivided geometry can help improving interaction, because the solid solver uses polygons to calculate collisions (too few points = inaccurate collisions).</p><a href=#bullet-and-vellum><h5 id=bullet-and-vellum><span class=hanchor arialabel=Anchor># </span>BULLET and VELLUM</h5></a><p>Mutual VELLUM - BULLET interaction is unfortunately not possible. You can somewhat fake it but it will always be a hacky workaround.</p><p>By now you can use <code>Shape Match Constraints</code> and <code>Vellum Transform Pieces</code> in VELLUM to achieve a similar look, though. Check out
<a href="https://www.youtube.com/watch?v=5s8I2fs8kMs" rel=noopener>John Lynch&rsquo;s Talk</a> about the topic!</p><a href=#colliders-and-substeps><h2 id=colliders-and-substeps><span class=hanchor arialabel=Anchor># </span>Colliders and Substeps</h2></a><a href=#substepping><h3 id=substepping><span class=hanchor arialabel=Anchor># </span>Substepping</h3></a><p>There are two areas where you can find substepping:</p><ol><li>The global substep rate used to march all solvers forward.</li><li>Local solver substepping</li></ol><p>Both of these have ramifications when it comes to collision geometry that is either animated or deforming. Static geometry is static so no issues there.</p><a href=#global-vs-solver-substeps><h3 id=global-vs-solver-substeps><span class=hanchor arialabel=Anchor># </span>Global vs Solver Substeps</h3></a><p>Global Substeps = Set on the DOP network / affects all microsolvers etc. end to end</p><p>Solver Substeps = Set on each micro solver or DOP object / affects only sub objects (closed system)</p><blockquote><p>// from the SideFX pdf:</p><p>Global substeps are easy to understand. The global substep rate is set at the top level DOP Network folder node. The node that contains the entire DOP network.</p><p>This rate forces all the solvers to sync up at these points in time.</p><p>Colliders are fetched from their SOP sources at these points. All the geometry for all the colliders is refreshed at these global substeps. Yes you can inject any geometry you like. Remove colliders, introduce new colliders. Your imagination is your only limit. In general colliders should move <strong>gracefully</strong> through your simulation. Solvers like that.</p><p>Solver substeps are solver specific substeps that divide up the time between global substeps in to smaller steps. Solver substeps are used for stability and accuracy within the solver.</p><p>FLIP solvers can be run at 2 or more substeps to prevent instability between global substeps. Actually in some cases will run 100 or more internal substeps.</p><p>Bullet Solver makes good use of substeps to prevent instability.</p><p>Solver substeps can be imagined as running in their own little world only communicating with the rest of the world at the global substeps. They will digest all their constraints including collision geometry and manage them in their own way.</p></blockquote><a href=#viewport-debugging-playback-rate><h3 id=viewport-debugging-playback-rate><span class=hanchor arialabel=Anchor># </span>Viewport Debugging (Playback Rate)</h3></a><p>To display substepped collision geometry you have to change the playback rate in the playbar options. You can set the rate to match the sub-frame global rate you set in the dop settings.</p><a href=#collider-substep-interpolation><h3 id=collider-substep-interpolation><span class=hanchor arialabel=Anchor># </span>Collider Substep Interpolation</h3></a><p>By default colliders are interpolated linearly, which works fine in most cases where objects move somewhat straight. If you need finer control it&rsquo;s best to cache out the colliders with substeps. More in the next section.</p><blockquote><p>// from the SideFX pdf:</p><p>If you are using the default shelf setup for deforming colliders, you are getting linear blending between frames. For most fast moving objects, this works because fast moving objects tend to travel relatively straight. But we are in VFX and directors want snappy animation and powerful movement.</p><p>In this case where you have snappy colliders moving very fast, that linear interpolation between frames can spell trouble. What you have is a trajectory that looks like a polygon curve with points at the frames and linear sequences. Those abrupt changes at the frames can do a lot of damage. Especially if an object is animated to stop almost instantaneously and then reflected upward or back.</p><p>That instantaneous change at the frame creates an almost infinite amount of energy that may cause issues</p></blockquote><a href=#smoothing-out-fast-moving-colliders><h3 id=smoothing-out-fast-moving-colliders><span class=hanchor arialabel=Anchor># </span>Smoothing Out Fast Moving Colliders</h3></a><p>To smooth out the motion of your colliders you have a few approaches:</p><ol><li>Cache out your colliders at subframes to minimize the abrupt changes.<ul><li>remember to change file cache <code>$F</code> variable to <code>$FF</code> to ensure correct file naming</li></ul></li><li>Rework your colliders to use animation curves for the transforms.</li></ol><blockquote><p>// from the SideFX pdf:</p><p>If your geometry is deforming rapidly in size, scaling up or down, then your only resort is the first option.</p><p>Actually the first option works well in most cases. Even providing one extra subframe of data works well.</p></blockquote><a href=#deforming-colliders><h2 id=deforming-colliders><span class=hanchor arialabel=Anchor># </span>Deforming Colliders</h2></a><p>If you need volume data for colliders always cache them to disk to improve performance! Also make sure to construct and provide a <code>collisionVel</code> velocity volume.</p><p>Each Solver deals with deforming collision geometry differently but there is a choice as to how we bring deforming geometry in to the Simulation environment:</p><ul><li>Deforming geometry cached to disk</li><li>Animated geometry at the object level</li><li>Crowd Agents</li></ul><blockquote><p>// from the SideFX pdf:</p><p>Many of the solvers have to deal with collision data as volume SDF data either as VDB caches or our own volume SDF caches. This is one area where VDB shines and is the recommended workflow both for less memory both on disk and in memory and the speed of VDB cache creation and loading from disk.</p></blockquote><p>Solvers that require VDB SDF volumetric data as colliders:</p><ul><li>Particle POP Solver and Grains PBD Solver</li><li>FLIP Solver</li><li>Pyro and Smoke Solvers</li></ul><a href=#general-collider-workflows><h2 id=general-collider-workflows><span class=hanchor arialabel=Anchor># </span>General Collider Workflows</h2></a><a href=#collision-vdbs-from-bad-topology><h3 id=collision-vdbs-from-bad-topology><span class=hanchor arialabel=Anchor># </span>Collision VDBs from Bad Topology</h3></a><p>When dealing with bad or damaged / &rsquo;non watertight&rsquo; topology you can use the <code>VDB Topology to SDF</code> node to approximate a surface from the bad vdb result you get from the <code>VDB from Polygons</code> node.</p><p><img src=/notes/images/badtopofix.png width=auto></p><a href=#performance><h3 id=performance><span class=hanchor arialabel=Anchor># </span>Performance</h3></a><p>To avoid regenerating collision geometry / vdbs of a moving but nondeforming object it makes sense to avoid SOP level animation and only animate on OBJ level and use the transform to move the collider in the DOP network. To do so you have to point the <code>OBJ Path</code> Parameter in the static object to the geo node containing your collider and enable <code>Use Object Transform</code>. This speeds up collider calculations massively. However you will lose per point collider velocities, because the geometry isn&rsquo;t moving in SOPs.</p><p><img src="/notes/images/collision base setup.png" width=auto></p><hr><p>sources / further reading:</p><ul><li><a href=https://www.sidefx.com/community/collision-geometry-in-dop-simulations/ rel=noopener>Collision Geometry in DOP Simulations - SideFX</a> includes demo files and a pdf summary<ul><li><a href=https://vimeo.com/252645795 rel=noopener>Collisions - Pt 1 | Jeff Wagner | Houdini Illume Webinar</a></li><li><a href=https://vimeo.com/254343083 rel=noopener>Collisions - Pt 2 (Colliders & Bullet Simulations) | Jeff Wagner | Houdini Illume Webinar</a></li><li><a href=https://vimeo.com/255979341 rel=noopener>Collisions - Pt 3 | Jeff Wagner | Houdini Illume Webinar</a></li></ul></li></ul></article><hr><div class=page-end><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li><a href=/notes/FLIP/ data-ctx=Collisions data-src=/notes/FLIP class=internal-link>FLIP</a></li><li><a href=/notes/Houdini/ data-ctx=Collisions data-src=/notes/Houdini class=internal-link>Houdini</a></li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://fxnotes.xyz/js/graph.8cefef8d9a78cb623e39ee66e5a4af0e.js></script></div></div><div id=contact_buttons><footer><p>Made by <a href=https://www.jakobringler.com>Jakob Ringler</a> using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2024</p><ul><li><a href=https://fxnotes.xyz/>Home</a></li><li><a href=https://twitter.com/jakobrin>Twitter</a></li><li><a href=https://github.com/jakobringler>Github</a></li><li><a href=https://fxnotes.xyz/notes/Legal/>Legal / Impressum</a></li></ul></footer></div></div></body></html>